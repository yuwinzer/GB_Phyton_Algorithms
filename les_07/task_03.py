#3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом. Найдите в массиве медиану.
# Медианой называется элемент ряда, делящий его на две равные части: в одной находятся элементы, которые не меньше
# медианы, в другой – не больше медианы. Задачу можно решить без сортировки исходного массива. Но если это слишком
# сложно, то используйте метод сортировки, который не рассматривался на уроках

# -----------------------------------------------------------------------------
#                                   Примечание
# За образец взят код на С++. Как оказалось срабатывал менее чем в половине случаев.
# Доработан для 100% результата. Работает на четном и нечетном количестве.
# Дробный результат округляется до большего целого.
# Скорее всего выборку медианы можно упростить.
# -----------------------------------------------------------------------------
#                                     Данные
import random
# import cProfile

ra_limin = 0
ra_limax = 100
ra_size = 2 * 100 + 1


# -----------------------------------------------------------------------------
#                                    Randomizer
def rnd(size, limit_1, limit_2):
    ra = []
    for i in range(size):
        ra.append(random.randint(limit_1, limit_2))
    return ra


# -----------------------------------------------------------------------------
#                                    Поиск медианы
def median_brute_search(array, delta_max):
    a_size = len(array)
    median = delta = m = 0
    for i in range(a_size):
        lower, higher = 0, 0  # кол-во бОльших и меньших элементов
        for j in range(a_size):  # сверяем каждый с каждым
            if array[j] != array[i]:
                if array[j] > array[i]:
                    higher += 1
                else:
                    lower += 1
        delta = abs(lower - higher)  # соотношение бОльших и меньших
        if delta < 4:  # если почти поровну, запоминаем последний меньший (нужен для большей точности)
            m = array[i]
        if delta == 0:  # если одинаковы - возвращаем резутьтат
            return array[i]
        elif delta_max + delta <= 3:  # если в течении двух циклов соотношение максимально близко
            # print(f'Result: {((m + median) >> 1) + (1 if (abs(m - median) % 2) > 0 else 0)}')
            return ((m + median) >> 1) + (1 if (abs(m - median) % 2) > 0 else 0)  # выводим результат, пока не разошлись
        else:  # иначе запоминаем текущее соотношение
            if delta <= delta_max:
                median = array[i]
                delta_max = delta
    # print(f'end: {median=} {delta_max=}  {delta=}   {m=}')
    return ((m + median) >> 1) + (1 if (abs(m - median) % 2) > 0 else 0)  # результат полной проверки


# -----------------------------------------------------------------------------
#                                      main func
def main():
    ra_1 = rnd(ra_size, ra_limin, ra_limax)
    print(f'array 1 ({ra_size}): {ra_1}')
    print(f'median: {median_brute_search(ra_1, ra_limax - ra_limin)}')

    # ra_2 = rnd(100, ra_limin, ra_limax)
    # print(f'array 2 (100): {ra_2}')
    # print(f'median: {median_brute_search(ra_2, ra_limax - ra_limin)}')

    # ra = [11, 15, 82, 86, 19, 66, 64, 99, 69, 30, 16, 47, 52, 95, 19, 61, 51, 51, 67, 57, 22, 11, 92, 38, 23, 45, 47, 91, 27, 17, 41, 38, 98, 48, 13, 98, 10, 70, 49, 76, 90, 68, 29, 81, 46, 88, 72, 80, 87, 60, 44, 34, 78, 16, 74, 18, 87, 50, 68, 6, 76, 95, 41, 58, 70, 14, 8, 89, 39, 18, 4, 51, 46, 35, 3, 66, 46, 9, 71, 100, 46, 56, 10, 85, 11, 66, 9, 26, 89, 27, 68, 69, 2, 16, 60, 83, 35, 96, 56, 4]
    # print(f'array 2 (100): {ra}')
    # print(f'median: {median_brute_search(ra, ra_limax - ra_limin)}')


# -----------------------------------------------------------------------------
#


# cProfile.run('main()')
main()